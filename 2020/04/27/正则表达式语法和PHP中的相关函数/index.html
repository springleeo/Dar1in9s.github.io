<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="PHP中的正则表达式语法和相关函数"><meta name="keywords" content="php,正则表达式"><meta name="author" content="Dar1in9"><meta name="copyright" content="Dar1in9"><title>PHP中的正则表达式语法和相关函数 | Dar1in9's Blog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><link rel="dns-prefetch" href="http://ta.qq.com"><script>(function() {
   var hm = document.createElement("script");
   hm.src = "https://tajs.qq.com/stats?sId=&lt;script type=&quot;text/javascript&quot; src=&quot;http://tajs.qq.com/stats?sId=66549793&quot; charset=&quot;UTF-8&quot;&gt;&lt;/script&gt;";
   var s = document.getElementsByTagName("script")[0];
   s.parentNode.insertBefore(hm, s);
 })();</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"MY1GAADR9W","apiKey":"5032629da4e94f659d98a4052bc1c5cd","indexName":"blog","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容:${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script><meta name="generator" content="Hexo 4.2.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#字符组"><span class="toc-number">1.</span> <span class="toc-text">字符组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#基本用法"><span class="toc-number">1.1.</span> <span class="toc-text">基本用法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#范围表示法-range"><span class="toc-number">1.2.</span> <span class="toc-text">范围表示法(range)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#字符组简记法-shorthands"><span class="toc-number">1.3.</span> <span class="toc-text">字符组简记法(shorthands)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#元字符与转义"><span class="toc-number">1.4.</span> <span class="toc-text">元字符与转义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#排除型字符组-Negated-Character-Class"><span class="toc-number">1.5.</span> <span class="toc-text">排除型字符组(Negated Character Class)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#量词"><span class="toc-number">2.</span> <span class="toc-text">量词</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#量词的一般形式"><span class="toc-number">2.1.</span> <span class="toc-text">量词的一般形式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#常用量词"><span class="toc-number">2.2.</span> <span class="toc-text">常用量词</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#点号"><span class="toc-number">2.3.</span> <span class="toc-text">点号</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#匹配优先量词、忽略优先量词"><span class="toc-number">2.4.</span> <span class="toc-text">匹配优先量词、忽略优先量词</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#括号"><span class="toc-number">3.</span> <span class="toc-text">括号</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#分组"><span class="toc-number">3.1.</span> <span class="toc-text">分组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#多选结构"><span class="toc-number">3.2.</span> <span class="toc-text">多选结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#引用分组"><span class="toc-number">3.3.</span> <span class="toc-text">引用分组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#非捕获分组"><span class="toc-number">3.4.</span> <span class="toc-text">非捕获分组</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#断言"><span class="toc-number">4.</span> <span class="toc-text">断言</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#单词边界"><span class="toc-number">4.1.</span> <span class="toc-text">单词边界</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#行起始-结束位置"><span class="toc-number">4.2.</span> <span class="toc-text">行起始&#x2F;结束位置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#环视"><span class="toc-number">4.3.</span> <span class="toc-text">环视</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#匹配模式"><span class="toc-number">5.</span> <span class="toc-text">匹配模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#不区分大小写模式"><span class="toc-number">5.1.</span> <span class="toc-text">不区分大小写模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#单行模式"><span class="toc-number">5.2.</span> <span class="toc-text">单行模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#多行模式"><span class="toc-number">5.3.</span> <span class="toc-text">多行模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#注释模式"><span class="toc-number">5.4.</span> <span class="toc-text">注释模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#非贪婪"><span class="toc-number">5.5.</span> <span class="toc-text">非贪婪</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Unicode"><span class="toc-number">5.6.</span> <span class="toc-text">Unicode</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#相关函数"><span class="toc-number">6.</span> <span class="toc-text">相关函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#preg-match"><span class="toc-number">6.1.</span> <span class="toc-text">preg_match</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#preg-match-all"><span class="toc-number">6.2.</span> <span class="toc-text">preg_match_all</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#preg-replace"><span class="toc-number">6.3.</span> <span class="toc-text">preg_replace</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#模式修饰符（PRCE）"><span class="toc-number">7.</span> <span class="toc-text">模式修饰符（PRCE）</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://blog-1300147235.cos.ap-chengdu.myqcloud.com/01.png"></div><div class="author-info__name text-center">Dar1in9</div><div class="author-info__description text-center">人间值得，未来可期</div><div class="follow-button"><a href="https://github.com/Dar1in9s" target="_blank" rel="noopener">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">54</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">21</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://blog-1300147235.cos.ap-chengdu.myqcloud.com/18085.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Dar1in9's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/about">About</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">PHP中的正则表达式语法和相关函数</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-04-27</time><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">5.5k</span><span class="post-meta__separator">|</span><span>阅读时长: 19 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>正则表达式由两种基本字符类型组成：原义(正常)文本字符和元字符。<br>元字符使正则表达式具有处理能力。元字符既可以是放在<code>[]</code>中的单个字符（<code>[a]</code>表示匹配单个小写字符<code>a</code>），也可以是字符序列（<code>[a-d]</code>表示匹配<code>a、b、c、d</code>之中的任意一个字符，而<code>\w</code>表示热议英文字母和数字以及下下划线）</p>
<a id="more"></a>

<h1 id="字符组"><a href="#字符组" class="headerlink" title="字符组"></a>字符组</h1><p>字符组就是一组字符，在正则表达式中，它表示<strong>在同一个位置可能出现的各种字符</strong>。<br>写法：<code>[ab]</code>、<code>[314]</code>、<code>[#.?]</code></p>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p><code>[...]</code></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">preg_match(<span class="string">'/[123]/'</span>, <span class="string">'2'</span>)    ==&gt; <span class="number">1</span></span><br><span class="line">preg_match(<span class="string">'/[123]/'</span>, <span class="string">'5'</span>)    ==&gt; <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h2 id="范围表示法-range"><a href="#范围表示法-range" class="headerlink" title="范围表示法(range)"></a>范围表示法(range)</h2><p><code>[x-y]</code>表示<code>x</code>到<code>y</code>整个范围内的字符。</p>
<p>如<code>[0123456789]</code>表示为<code>[0-9]</code>，<code>[abcdefghijk]</code>表示为<code>[a-k]</code></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">preg_match(<span class="string">'/[0-9]/'</span>, <span class="string">'6'</span>)        ==&gt; <span class="number">1</span></span><br><span class="line">preg_match(<span class="string">'/[0-9]/'</span>, <span class="string">'6'</span>)        ==&gt; <span class="number">0</span></span><br><span class="line">preg_match(<span class="string">'/[0-9a-fA-F]/'</span>, <span class="string">'0'</span>)  ==&gt; <span class="number">1</span> <span class="comment">//匹配16进制数</span></span><br></pre></td></tr></table></figure>

<h2 id="字符组简记法-shorthands"><a href="#字符组简记法-shorthands" class="headerlink" title="字符组简记法(shorthands)"></a>字符组简记法(shorthands)</h2><p>提供比范围表示法更简洁的表示方法，如<code>\d</code>表示<code>[0-9]</code>，<code>\w</code>表示<code>[0-9a-zA-z_]</code></p>
<p>php中支持的字符组简记：</p>
<ul>
<li><code>\d</code> 所有的数字，即<code>[0-9]</code></li>
<li><code>\D</code> 所有的非数字，与<code>\d</code>互斥</li>
<li><code>\w</code> 所有的单词字符（字符、数字、下划线），即<code>[0-9a-zA-Z_]</code></li>
<li><code>\W</code> 所有的非单词字符，与<code>\W</code>互斥</li>
<li><code>\s</code> 所有的空白字符，包括空格、制表符、回车符、换行符等空白字符</li>
<li><code>\S</code> 所有的非空白字符，与<code>\s</code>互斥</li>
</ul>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">preg_match(<span class="string">'/\d/'</span>, <span class="string">'8'</span>)       ==&gt; <span class="number">1</span></span><br><span class="line">preg_match(<span class="string">'/\d/'</span>, <span class="string">'a'</span>)       ==&gt; <span class="number">0</span></span><br><span class="line">preg_match(<span class="string">'/\d[a-z]/'</span>, <span class="string">'0a'</span>) ==&gt; <span class="number">1</span></span><br><span class="line"></span><br><span class="line">preg_match(<span class="string">'/\w/'</span>, <span class="string">'a'</span>);      ==&gt; <span class="number">1</span></span><br><span class="line">preg_match(<span class="string">'/\w/'</span>, <span class="string">'6'</span>);      ==&gt; <span class="number">1</span></span><br><span class="line">preg_match(<span class="string">'/\w/'</span>, <span class="string">'_'</span>);      ==&gt; <span class="number">1</span></span><br><span class="line"></span><br><span class="line">preg_match(<span class="string">'/\s/'</span>, <span class="string">' '</span>);      ==&gt; <span class="number">1</span></span><br><span class="line">preg_match(<span class="string">'/\s/'</span>, <span class="string">"\t"</span>);     ==&gt; <span class="number">1</span></span><br><span class="line">preg_match(<span class="string">'/\s/'</span>, <span class="string">"\r"</span>);     ==&gt; <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="元字符与转义"><a href="#元字符与转义" class="headerlink" title="元字符与转义"></a>元字符与转义</h2><p>在范围表示法中，字符组中的横线<code>-</code>不能匹配横线字符，而是用来表示范围，这类字符叫做<strong>元字符</strong>。<br>元字符除了<code>-</code>还有<code>[、]、^、$</code>…，他们都有特殊的意义。</p>
<p>当元字符想要表示普通字符的含义时（如<code>-</code>就只想表示横线字符），就需要转义处理（在元字符前加反斜线<code>\</code>）。<br>对于<code>-</code>，有一个例外情况，就是当它紧跟着字符组的左方括号<code>[</code>时，它就表示普通横线字符，此时不用转义。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">preg_match(<span class="string">'/[0\-9]/'</span>, <span class="string">"-"</span>)    ==&gt; <span class="number">1</span></span><br><span class="line">preg_match(<span class="string">'/[0\-9]/'</span>, <span class="string">"8"</span>)    ==&gt; <span class="number">0</span></span><br><span class="line">preg_match(<span class="string">'/[0\-9]/'</span>, <span class="string">"0"</span>)    ==&gt; <span class="number">1</span></span><br><span class="line"></span><br><span class="line">preg_match(<span class="string">'/[-09]/'</span>, <span class="string">"-"</span>)     ==&gt; <span class="number">1</span></span><br><span class="line"></span><br><span class="line">preg_match(<span class="string">"/[0\\-9]/"</span>, <span class="string">"-"</span>)   ==&gt; <span class="number">1</span></span><br><span class="line">preg_match(<span class="string">"/[0\-9]/"</span>, <span class="string">"-"</span>)    ==&gt; <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>仔细看上面第一个表达式和最后两个表示式。这里要注意：</p>
<ul>
<li>在php中，字符串既可以用单引号标注，也可以用双引号标注。<br>两者的主要区别在于双引号字符串可以解析变量，而但引号字符串不能。<br>另外，<strong>双引号字符串会处理字符转义，而单引号字符串不会(唯独会转义<code>\</code>)</strong></li>
<li>正则表达式是以字符串的方式提供的。在php中，双引号字符串本身也有关于转义的规定（如<code>&quot;\\&quot;</code>、<code>&#39;\r&#39;</code>、<code>&quot;\t&quot;</code>等），因此<code>&quot;0\\-9&quot;</code>与<code>&#39;0\-9&#39;</code>是等价的。</li>
<li>那么最后一个表达式为什么也可以匹配呢？<br>这是因为，尽管php的正则表达式用字符串文字给出，但它与常见的字符串不完全一样 —— <strong>如果某个转义序列可以有字符串识别，则对其进行转义处理；否则，将整个转义序列“原封不动”地保存下来</strong>。<br>最后一个表达式的<code>\-</code>并没有什么特殊意义，即将其原样保存</li>
</ul>
<h2 id="排除型字符组-Negated-Character-Class"><a href="#排除型字符组-Negated-Character-Class" class="headerlink" title="排除型字符组(Negated Character Class)"></a>排除型字符组(Negated Character Class)</h2><p>在方括号<code>[…]</code>中列出希望匹配的所有字符叫做“<strong>普通字符组</strong>”。在开方括号<code>[</code>之后紧跟一个脱字符<code>^</code>，写作<code>[^…]</code>，表示“<strong>在当前位置，匹配一个没有列出的字符</strong>”。例如，<code>[^0-9]</code>匹配非数字字符。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">preg_match(<span class="string">'/[^0-9][0-9]/'</span>, <span class="string">"A1"</span>)   ==&gt; <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>排除型字符组中的紧跟着开方括号<code>[</code>的脱字符<code>^</code>也是元字符，如果要匹配尖括号字符，需要进行转义处理。但是，不紧跟着开方括号<code>[</code>的<code>^</code>就是普通字符，不需要转义。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">preg_match(<span class="string">'/[^0-9]/'</span>, <span class="string">'0'</span>)     ==&gt; <span class="number">0</span></span><br><span class="line">preg_match(<span class="string">'/[\^0-9]/'</span>, <span class="string">'0'</span>)    ==&gt; <span class="number">1</span></span><br><span class="line">preg_match(<span class="string">'/[\^0-9]/'</span>, <span class="string">'^'</span>)    ==&gt; <span class="number">1</span></span><br><span class="line">preg_match(<span class="string">'/[0-9^]/'</span>, <span class="string">'^'</span>)     ==&gt; <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h1 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h1><p>首先看看<code>^</code>和<code>$</code>两个特殊字符</p>
<ul>
<li><code>^</code>放在正则表达式的开头，表示“定位到字符串的起始位置”；</li>
<li><code>$</code>用在正则表达式的末尾，表示“定位到字符串的结束位置”。</li>
</ul>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">preg_match(<span class="string">'/\w\d/'</span>, <span class="string">'1a2b'</span>)    ==&gt; <span class="number">1</span> 匹配到的是 a2</span><br><span class="line">preg_match(<span class="string">'/^\w\d/'</span>, <span class="string">'1a2b'</span>)   ==&gt; <span class="number">0</span> 第二个字符必须是数字</span><br><span class="line">preg_match(<span class="string">'/\w\d$/'</span>, <span class="string">'1a2b'</span>)   ==&gt; <span class="number">0</span> 必须以数字结尾</span><br><span class="line">preg_match(<span class="string">'/^\w\d/'</span>, <span class="string">'a2b'</span>)    ==&gt; <span class="number">1</span> 匹配到的是a2</span><br><span class="line">preg_match(<span class="string">'/\w\d$/'</span>, <span class="string">'1a2'</span>)    ==&gt; <span class="number">1</span> 匹配到的是a2</span><br><span class="line">preg_match(<span class="string">'/^\w\d$/'</span>, <span class="string">'1a2'</span>)   ==&gt; <span class="number">0</span> 只能是两个字符，最后一个是数字</span><br><span class="line">preg_match(<span class="string">'/^\w\d$/'</span>, <span class="string">'a2'</span>)    ==&gt; <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="量词的一般形式"><a href="#量词的一般形式" class="headerlink" title="量词的一般形式"></a>量词的一般形式</h2><p>如果要匹配一个邮政编码（6位数字），目前能写出来的正则表达式是<code>^\d\d\d\d\d\d$</code>。<br><code>\d</code>重复6次的写法很不科学，正则表达式肯定会有更方便的写法，也就是<strong>量词</strong>。量词的通用形式是<code>{m,n}</code>（注意，<code>,</code>后面不能有空格），它限定之前的元素能够出现的次数，<code>m</code>是下限，<code>n</code>是上限。其他常见的量词形式有：</p>
<table>
<thead>
<tr>
<th>量词</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>{n}</code></td>
<td>之前的元素必须出现n次</td>
</tr>
<tr>
<td><code>{m,n}</code></td>
<td>之前的元素最少出现m次，最多出现n次</td>
</tr>
<tr>
<td><code>{m,}</code></td>
<td>之前的元素最少出现m次，出现次数无上限</td>
</tr>
<tr>
<td><code>{0,n}</code></td>
<td>之前的元素可以不出现，也可以出现，最多出现n次</td>
</tr>
</tbody></table>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">preg_match(<span class="string">'/^\d&#123;6&#125;$/'</span>, <span class="string">'100010'</span>)      ==&gt; <span class="number">1</span></span><br><span class="line"></span><br><span class="line">preg_match(<span class="string">'/^\d&#123;4,6&#125;$/'</span>, <span class="string">'123'</span>)       ==&gt; <span class="number">0</span></span><br><span class="line">preg_match(<span class="string">'/^\d&#123;4,6&#125;$/'</span>, <span class="string">'1234'</span>)      ==&gt; <span class="number">1</span></span><br><span class="line">preg_match(<span class="string">'/^\d&#123;4,6&#125;$/'</span>, <span class="string">'123456'</span>)    ==&gt; <span class="number">1</span></span><br><span class="line">preg_match(<span class="string">'/^\d&#123;4,6&#125;$/'</span>, <span class="string">'1234567'</span>)   ==&gt; <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h2 id="常用量词"><a href="#常用量词" class="headerlink" title="常用量词"></a>常用量词</h2><p>正则表达式还有三个常用的量词，分别是<code>+</code>、<code>?</code>、<code>*</code>：</p>
<table>
<thead>
<tr>
<th>常用量词</th>
<th><code>{m,n}</code>等价形式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>{0,}</td>
<td>可能出现，也可能不出现，出现次数没有上限</td>
</tr>
<tr>
<td>+</td>
<td>{1,}</td>
<td>至少出现1次，出现次数没有上限</td>
</tr>
<tr>
<td>?</td>
<td>{0,1}</td>
<td>出现0次或1次</td>
</tr>
</tbody></table>
<h2 id="点号"><a href="#点号" class="headerlink" title="点号"></a>点号</h2><p>点号<code>.</code>是与量词搭配比较多得一个字符。一般情况下，点号<code>.</code>可以匹配除了换行符<code>\n</code>以外的任意字符。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">preg_match(<span class="string">'/^.$/'</span>, <span class="string">'z'</span>)    ==&gt; <span class="number">1</span></span><br><span class="line">preg_match(<span class="string">'/^.$/'</span>, <span class="string">'8'</span>)    ==&gt; <span class="number">1</span></span><br><span class="line">preg_match(<span class="string">'/^.$/'</span>, <span class="string">"\n"</span>)   ==&gt; <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>如果要使达到<code>.</code>能匹配的字符包含换行符<code>\n</code>的效果，可以使用自制通配符<code>\s\S</code>或<code>\w\W</code>、<code>\d\D</code>。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">preg_match(<span class="string">'/^[\s\S]$/'</span>, <span class="string">"\n"</span>)   ==&gt; <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>使<code>.</code>能匹配的字符包含换行符<code>\n</code>的另外一种方法是指定正则匹配时使用<strong>单行模式</strong>。<br>在php中，可以使用模式修饰符和预定义常量两种方法来指定单行模式。关于正则匹配的模式，后面会详细介绍。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">preg_match(<span class="string">'/(?s)^.$/'</span>, <span class="string">"\n"</span>)  ==&gt; <span class="number">1</span>  模式修饰符</span><br><span class="line">preg_match(<span class="string">'/^.$/s'</span>, <span class="string">"\n"</span>)     ==&gt; <span class="number">1</span>  预定义常量</span><br></pre></td></tr></table></figure>

<h2 id="匹配优先量词、忽略优先量词"><a href="#匹配优先量词、忽略优先量词" class="headerlink" title="匹配优先量词、忽略优先量词"></a>匹配优先量词、忽略优先量词</h2><p>先看一个例子：</p>
<p>很多语言中，都可以使用<code>/*...*/</code>来注释代码，如果是一个支持语法高亮的文本编辑器就要能够提取<code>/*...*/</code>注释块。很easy的，我们可以写出如下正则表达式：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$str = <span class="string">'/*this is a comment*/ /*this is another comment*/'</span>;</span><br><span class="line">preg_match(<span class="string">'/\/\*.*\*\//'</span>, $str, $arr);</span><br><span class="line"><span class="keyword">echo</span> $arr[<span class="number">0</span>];   ==&gt; <span class="comment">/*this is a comment*/</span> <span class="comment">/*this is another comment*/</span></span><br></pre></td></tr></table></figure>
<p>可以看到，这个正则表达式出了点小问题，它把两个注释块匹配出来了，如果两个注释块中间有代码，那么代码也会匹配出来。</p>
<p>这是因为，我们介绍的<code>*、+、?</code>都是<strong>匹配优先量词</strong>（greedy quantifier，也称贪婪量词）。<br><strong>匹配优先量词是指在拿不准是否要匹配的时候，优先尝试匹配</strong>。因此，<code>$str</code>中间的<code>*/ /*</code>都被<code>.*</code>匹配了。</p>
<p>正则表达式中利用<strong>忽略优先量词</strong>来解决上述问题。与<code>*、+、?</code>对应的忽略优先量词的形式是<code>*?、+?、??</code>。<br><strong>忽略优先量词在不确定是否要匹配时选择“不匹配”的状态</strong>。</p>
<p>还是以提取注释块的代码为例：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">preg_match(<span class="string">'/\/\*.*?\*\//'</span>, $str, $arr);</span><br><span class="line"><span class="keyword">echo</span> $arr[<span class="number">0</span>];      ==&gt;  <span class="comment">/*this is a comment*/</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>匹配优先量词</th>
<th>忽略优先量词</th>
<th>限定次数</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>*？</td>
<td>可能出现，可能不出现，出现次数没有上限</td>
</tr>
<tr>
<td>+</td>
<td>+？</td>
<td>至少出现1次，没有上限</td>
</tr>
<tr>
<td>?</td>
<td>??</td>
<td>出现0次或1次</td>
</tr>
<tr>
<td>{m,n}</td>
<td>{m,n}?</td>
<td>出现次数大于等于m，小于等于n</td>
</tr>
<tr>
<td>{m,}</td>
<td>{m,}?</td>
<td>至少出现m次，没有上限</td>
</tr>
<tr>
<td>{0,n}</td>
<td>{0,n}?</td>
<td>出现0次-n次</td>
</tr>
</tbody></table>
<p>php中有指定非贪婪匹配模式的<code>模式修饰符</code>和<code>预定义常量</code>，与<code>忽略优先量词</code>是一样的效果：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认贪婪匹配</span></span><br><span class="line">preg_match(<span class="string">'/\/\*.*\*\//'</span>, $str, $arr);      ==&gt; <span class="comment">/*this is a comment*/</span> <span class="comment">/*this is another comment*/</span> </span><br><span class="line"><span class="comment">// 预定义常量 指定非贪婪匹配</span></span><br><span class="line">preg_match(<span class="string">'/\/\*.*\*\//U'</span>, $str, $arr);     ==&gt; <span class="comment">/*this is a comment*/</span> </span><br><span class="line"><span class="comment">// 模式修饰符 指定非贪婪匹配</span></span><br><span class="line">preg_match(<span class="string">'/(?U)\/\*.*\*\//'</span>, $str, $arr);  ==&gt; <span class="comment">/*this is a comment*/</span> </span><br><span class="line"><span class="comment">// 同时使用 忽略优先量词 和 预定义常量</span></span><br><span class="line">preg_match(<span class="string">'/\/\*.*?\*\//U'</span>, $str, $arr);    ==&gt; <span class="comment">/*this is a comment*/</span> <span class="comment">/*this is another comment*/</span></span><br><span class="line"><span class="comment">// 同时使用 忽略优先量词 和 模式修饰符</span></span><br><span class="line">preg_match(<span class="string">'/(?U)\/\*.*?\*\//'</span>, $str, $arr); ==&gt; <span class="comment">/*this is a comment*/</span> <span class="comment">/*this is another comment*/</span></span><br></pre></td></tr></table></figure>

<h1 id="括号"><a href="#括号" class="headerlink" title="括号"></a>括号</h1><h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><p>上面介绍了量词，例子中量词都只能控制它前面的字符或字符组。那么量词能否控制连续的字符或字符组呢，如控制一个单词<code>hello</code>出现或者不出现。这就要用到正则表达式的<strong>分组</strong>功能（子表达式），使用圆括号<code>(...)</code>实现分组（子表达式）。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 量词限定前面一个字符</span></span><br><span class="line">preg_match(<span class="string">'/^hello?, world$/'</span>, <span class="string">'hello, world'</span>);   ==&gt; <span class="number">1</span></span><br><span class="line">preg_match(<span class="string">'/^hello?, world$/'</span>, <span class="string">'hell, world'</span>);    ==&gt; <span class="number">1</span></span><br><span class="line">preg_match(<span class="string">'/^hello?, world$/'</span>, <span class="string">', world'</span>);        ==&gt; <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 量词限定一个单词</span></span><br><span class="line">preg_match(<span class="string">'/^(hello)?, world$/'</span>, <span class="string">'hello, world'</span>); ==&gt; <span class="number">1</span></span><br><span class="line">preg_match(<span class="string">'/^(hello)?, world$/'</span>, <span class="string">'hell, world'</span>);  ==&gt; <span class="number">0</span></span><br><span class="line">preg_match(<span class="string">'/^(hello)?, world$/'</span>, <span class="string">', world'</span>);      ==&gt; <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="多选结构"><a href="#多选结构" class="headerlink" title="多选结构"></a>多选结构</h2><p>多选结构（alternative）的形式是<code>(...|...)</code>，在括号内以竖线<code>|</code>分开多个子表达式，这些子表达式也叫多选分支（option）。</p>
<p>例如，匹配常见的11位手机号</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">preg_match(<span class="string">'/(13[0-9]|15[0-356]|18[025-9])\d&#123;8&#125;/'</span>, <span class="string">'18521510001'</span>);    ==&gt; <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="引用分组"><a href="#引用分组" class="headerlink" title="引用分组"></a>引用分组</h2><p>正则表达式会保存每个<code>(...)</code>分组匹配的文本，这种功能叫<strong>捕获分组</strong>（capturing group）。在需要直接使用子表达式的时候非常有用</p>
<p>例如，提取<code>&lt;a&gt;</code>标签中的地址和描述文本</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">preg_match(<span class="string">'/&lt;a\s+href="([^\'"\s]*)"&gt;(.*?)&lt;\/a&gt;/'</span>, <span class="string">'&lt;a href="github.com"&gt;visit github&lt;/a&gt;'</span>, $arr);</span><br><span class="line">print_r($arr);</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line"><span class="keyword">Array</span></span><br><span class="line">(</span><br><span class="line">    [<span class="number">0</span>] =&gt; &lt;a href=<span class="string">"github.com"</span>&gt;github&lt;/a&gt;</span><br><span class="line">    [<span class="number">1</span>] =&gt; github.com</span><br><span class="line">    [<span class="number">2</span>] =&gt; visit github</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>正则表达式替换时也支持捕获分组。php中支持<code>\num</code>和<code>$num</code>的形式替换，但是<code>num</code>不能大于10；另一种形式<code>${num}</code>可以大于10。</p>
<p>例如，日期的替换</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">preg_replace(<span class="string">'/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/'</span>, <span class="string">'$1年$2月$3日'</span>, <span class="string">'2015-08-25'</span>);    ==&gt; <span class="number">2015</span>年<span class="number">08</span>月<span class="number">25</span>日</span><br><span class="line">preg_replace(<span class="string">'/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/'</span>, <span class="string">'\1年\2月\3日'</span>, <span class="string">'2015-08-25'</span>);    ==&gt; <span class="number">2015</span>年<span class="number">08</span>月<span class="number">25</span>日</span><br></pre></td></tr></table></figure>

<h2 id="非捕获分组"><a href="#非捕获分组" class="headerlink" title="非捕获分组"></a>非捕获分组</h2><p>正则表达式默认会保存每个<code>(...)</code>匹配的文本，前面利用这个特性可以实现一些有用的功能。但是，有时候正则表达式比较复杂，<code>(...)</code>会出现的比较多，而此时仅仅是想实现分组或者多选的功能，而不需要捕获分组；同时，大量不需要的捕获分组可能会影响性能。<br>为了解决这种问题，正则表达式提供了<strong>非捕获分组</strong>（non-capturing group），它的形式是<code>(?:...)</code>。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 捕获分组</span></span><br><span class="line">preg_match(<span class="string">'/(13[0-9]|15[0-356]|18[025-9])\d&#123;8&#125;/'</span>, <span class="string">'18521510001'</span>, $arr);    ==&gt; <span class="number">1</span></span><br><span class="line">print_r($arr);                                                            </span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line"><span class="keyword">Array</span></span><br><span class="line">(</span><br><span class="line">    [<span class="number">0</span>] =&gt; <span class="number">18521510001</span></span><br><span class="line">    [<span class="number">1</span>] =&gt; <span class="number">185</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非捕获分组</span></span><br><span class="line"><span class="keyword">echo</span> preg_match(<span class="string">'/(?:13[0-9]|15[0-356]|18[025-9])\d&#123;8&#125;/'</span>, <span class="string">'18521510001'</span>, $arr);   ==&gt; <span class="number">1</span></span><br><span class="line">print_r($arr);                                                            </span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line"><span class="keyword">Array</span></span><br><span class="line">(</span><br><span class="line">    [<span class="number">0</span>] =&gt; <span class="number">18521510001</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h1><p>正则表达式中的有些结构不匹配真正的文本，只负责<strong>判断</strong>在某个位置左/右侧的文本<strong>是否符合要求</strong>，这种结构称为<strong>断言</strong>（assertion）。<br>常见的断言有三类：单词边界、行起始/结束位置、环视。</p>
<h2 id="单词边界"><a href="#单词边界" class="headerlink" title="单词边界"></a>单词边界</h2><p>单词边界（word boundary)，记为<code>\b</code>。<br>它匹配的是单词边界（一边是单词字符，另一边不是单词字符）的位置，而不是字符。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单词边界</span></span><br><span class="line">preg_match(<span class="string">'/\b\w+\b/'</span>, <span class="string">'word'</span>, $arr);  <span class="comment">// =&gt; 1</span></span><br><span class="line">print_r($arr);</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line"><span class="keyword">Array</span></span><br><span class="line">(</span><br><span class="line">    [<span class="number">0</span>] =&gt; word</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配所有单词边界</span></span><br><span class="line">preg_match_all(<span class="string">'/\b\w+\b/'</span>, <span class="string">'hello, world'</span>, $arr);  <span class="comment">// =&gt; 2</span></span><br><span class="line">print_r($arr);</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line"><span class="keyword">Array</span></span><br><span class="line">(</span><br><span class="line">    [<span class="number">0</span>] =&gt; <span class="keyword">Array</span></span><br><span class="line">        (</span><br><span class="line">            [<span class="number">0</span>] =&gt; hello</span><br><span class="line">            [<span class="number">1</span>] =&gt; world</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>这类匹配位置而不匹配字符的元素叫做<strong>锚点</strong>（anchor），下一节要介绍的<code>^</code>、<code>$</code>等也是锚点。</p>
<h2 id="行起始-结束位置"><a href="#行起始-结束位置" class="headerlink" title="行起始/结束位置"></a>行起始/结束位置</h2><p><code>^</code>：字符串的开始位置<br><code>$</code>：字符串的结束位置</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">$str = <span class="string">'first line</span></span><br><span class="line"><span class="string">second line</span></span><br><span class="line"><span class="string">last line'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串起始位置</span></span><br><span class="line">preg_match_all(<span class="string">'/^\w+\b/'</span>, $str, $arr); <span class="comment">// =&gt; 1</span></span><br><span class="line">print_r($arr);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Array</span></span><br><span class="line"><span class="comment">(</span></span><br><span class="line"><span class="comment">    [0] =&gt; Array</span></span><br><span class="line"><span class="comment">        (</span></span><br><span class="line"><span class="comment">            [0] =&gt; first</span></span><br><span class="line"><span class="comment">        )</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串结束位置</span></span><br><span class="line">preg_match_all(<span class="string">'/\b\w+$/'</span>, $str, $arr); <span class="comment">// =&gt; 1</span></span><br><span class="line">print_r($arr);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Array</span></span><br><span class="line"><span class="comment">(</span></span><br><span class="line"><span class="comment">    [0] =&gt; Array</span></span><br><span class="line"><span class="comment">        (</span></span><br><span class="line"><span class="comment">            [0] =&gt; line</span></span><br><span class="line"><span class="comment">        )</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>如果指定了多行模式（Multiline Mode），<code>^</code>、<code>$</code>分别可以匹配行起始位置、行结束位置。<br>关于模式，将在后面详细介绍。指定多行模式的方式是使用模式修饰符<code>(?m)</code>：在正则表达式之前加上<code>(?m)</code>；或者是预定义常量的方式：<code>/.../m</code> 。</p>
<h2 id="环视"><a href="#环视" class="headerlink" title="环视"></a>环视</h2><p>环视（look-around）用来“停在原地，四处张望”，它本身也不匹配任何字符，用来限定它旁边的文本满足某种条件。</p>
<table>
<thead>
<tr>
<th>名字</th>
<th>记法</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>肯定顺序环视</td>
<td><code>(?=...)</code></td>
<td>向右看看，右边出现了环视中的内容才匹配</td>
</tr>
<tr>
<td>否定顺序环视</td>
<td><code>(?!...)</code></td>
<td>向右看看，右边不出现环视中的内容才匹配</td>
</tr>
<tr>
<td>肯定逆序环视</td>
<td><code>(?&lt;=...)</code></td>
<td>向左看看，左边出现了环视中的内容才匹配</td>
</tr>
<tr>
<td>否定逆序环视</td>
<td><code>(?&lt;!...)</code></td>
<td>向左看看，左边不出现环视中的内容才匹配</td>
</tr>
</tbody></table>
<p>比如在字符串格式化时匹配<code>%s</code>，要求<code>%s</code>的前面一个字符不能是<code>%</code>：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">preg_match(<span class="string">'/(?&lt;!%)%s/'</span>, <span class="string">"%s"</span>);   ==&gt; <span class="number">1</span></span><br><span class="line">preg_match(<span class="string">'/(?&lt;!%)%s/'</span>, <span class="string">"%%s"</span>);  ==&gt; <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h1 id="匹配模式"><a href="#匹配模式" class="headerlink" title="匹配模式"></a>匹配模式</h1><p>前面的内容中已经出现过了<strong>单行模式</strong>、<strong>多行模式</strong>、<strong>非贪婪模式</strong>。<br>匹配模式是指匹配时使用的规则。常用的匹配模式还有<strong>不区分大小写模式</strong>、<strong>注释模式</strong>。</p>
<p>在开始介绍具体的模式之前，先介绍php中模式的两种具体实现<code>/.../{modifier}</code>和<code>...(?{modifier})...</code>：</p>
<table>
<thead>
<tr>
<th>模式修饰符</th>
<th><code>/.../{modifier}</code></th>
<th><code>...(?{modifier})...</code></th>
</tr>
</thead>
<tbody><tr>
<td>示例</td>
<td><code>/&lt;tr&gt;.*&lt;\/tr&gt;/s</code></td>
<td><code>&lt;tr&gt;(?s).*&lt;\/tr&gt;</code></td>
</tr>
<tr>
<td>名称(php手册)</td>
<td>模式修饰符</td>
<td>模式内修饰符</td>
</tr>
<tr>
<td>名称(正则指引)</td>
<td>预定义变量</td>
<td>模式修饰符</td>
</tr>
<tr>
<td>作用范围</td>
<td>整个表达式</td>
<td>不在分组（子表达式）中时，对它后面的全部正则表达式起作用；如果在分组（子表达式）中，则对它分组中的剩余部分起作用。在没有分组，且放在整个正则表达式最前面的时候相当于<code>/.../{modifier}</code></td>
</tr>
<tr>
<td>支持程度</td>
<td>支持所有模式修饰符</td>
<td>支持部分模式修饰符</td>
</tr>
<tr>
<td>其他编程语言</td>
<td>可能不支持</td>
<td>一般都支持</td>
</tr>
</tbody></table>
<h2 id="不区分大小写模式"><a href="#不区分大小写模式" class="headerlink" title="不区分大小写模式"></a>不区分大小写模式</h2><p>在html中是不区分大小写的，例如<code>&lt;td&gt;</code>和<code>&lt;tD&gt;</code>、<code>&lt;Td&gt;</code>、<code>&lt;TD&gt;</code>的作用是一样的。如果要从网页中提取<code>&lt;td&gt;</code>，不使用匹配模式的表达式应该是这样：<br><code>&lt;[tT][dD]&gt;</code></p>
<p>由于<code>&lt;td&gt;</code>标签只有两个字符，所以上面的写法还可以接受。但是如果标签是<code>&lt;script&gt;</code>呢？这里，就需要使用不区分大小写模式：<code>/.../i</code>或<code>...(?i)...</code>。上面的正则表达式可以进一步写为：<br><code>/&lt;td&gt;/i或(?i)&lt;td&gt;</code></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">preg_match(<span class="string">'/(?i)&lt;td&gt;/'</span>, <span class="string">'&lt;tD&gt;'</span>, $arr);</span><br><span class="line"><span class="comment">//preg_match('/&lt;td&gt;/i', '&lt;tD&gt;', $arr);</span></span><br><span class="line">print_r($arr);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Array</span></span><br><span class="line"><span class="comment">(</span></span><br><span class="line"><span class="comment">    [0] =&gt; &lt;tD&gt;</span></span><br><span class="line"><span class="comment">)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>


<h2 id="单行模式"><a href="#单行模式" class="headerlink" title="单行模式"></a>单行模式</h2><p>形式：<code>/.../s</code>或<code>...(?s)...</code></p>
<p>作用：点号可以匹配换行符</p>
<h2 id="多行模式"><a href="#多行模式" class="headerlink" title="多行模式"></a>多行模式</h2><p>与单行模式没有关系。影响<code>^</code>和<code>$</code>的匹配</p>
<p>形式：<code>/.../x</code>或<code>...(?m)...</code></p>
<h2 id="注释模式"><a href="#注释模式" class="headerlink" title="注释模式"></a>注释模式</h2><p><code>(?#...)</code>的方法可以在正则表达式中添加注释</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// (?#...)注释</span></span><br><span class="line">preg_match(<span class="string">'/(?#this is comment)(?i)&lt;td&gt;/'</span>, <span class="string">'&lt;tD&gt;'</span>, $arr);</span><br><span class="line">print_r($arr);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Array</span></span><br><span class="line"><span class="comment">(</span></span><br><span class="line"><span class="comment">    [0] =&gt; &lt;tD&gt;</span></span><br><span class="line"><span class="comment">)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="非贪婪"><a href="#非贪婪" class="headerlink" title="非贪婪"></a>非贪婪</h2><p>形式：<code>/.../U</code>或<code>...(?U)...</code></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认贪婪匹配</span></span><br><span class="line">$str = <span class="string">'&lt;tr&gt;&lt;td&gt;hello&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;world&lt;/td&gt;&lt;/tr&gt;'</span>;</span><br><span class="line">preg_match(<span class="string">'/&lt;tr&gt;.*&lt;\/tr&gt;/'</span>, $str, $arr);</span><br><span class="line">print_r($arr);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Array</span></span><br><span class="line"><span class="comment">(</span></span><br><span class="line"><span class="comment">    [0] =&gt; &lt;tr&gt;&lt;td&gt;hello&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;world&lt;/td&gt;&lt;/tr&gt;</span></span><br><span class="line"><span class="comment">)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 非贪婪匹配模式</span></span><br><span class="line">$str = <span class="string">'&lt;tr&gt;&lt;td&gt;hello&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;world&lt;/td&gt;&lt;/tr&gt;'</span>;</span><br><span class="line">preg_match(<span class="string">'/&lt;tr&gt;.*&lt;\/tr&gt;/U'</span>, $str, $arr);</span><br><span class="line">print_r($arr);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Array</span></span><br><span class="line"><span class="comment">(</span></span><br><span class="line"><span class="comment">    [0] =&gt; &lt;tr&gt;&lt;td&gt;hello&lt;/td&gt;&lt;/tr&gt;</span></span><br><span class="line"><span class="comment">)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h2><p>要匹配中文等Unicode字符，最好是指定Unicode模式修饰符<code>/.../u</code>。如果不指定会有两个问题</p>
<ul>
<li>GBK编码环境下，中文不能匹配</li>
<li>无法利用<code>[\x{4e00}-\x{9fff}]</code>匹配中文</li>
</ul>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定unicode模式</span></span><br><span class="line">preg_match(<span class="string">'/&lt;td&gt;[\x&#123;4e00&#125;-\x&#123;9fff&#125;]*&lt;\/td&gt;/u'</span>, <span class="string">'&lt;td&gt;姚明&lt;/td&gt;'</span>, $arr);</span><br><span class="line">print_r($arr);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Array</span></span><br><span class="line"><span class="comment">(</span></span><br><span class="line"><span class="comment">    [0] =&gt; &lt;td&gt;姚明&lt;/td&gt;</span></span><br><span class="line"><span class="comment">)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>


<h1 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h1><p>在PHP中，有两套正则表达式函数库。<br>1.<code>POSIX</code> 扩展的正则表达式函数（<code>ereg_</code>）。<br>2.<code>Perl</code> 兼容的正则表达式函数（<code>preg_</code>）。</p>
<p><code>Perl</code>兼容的函数库是后加的函数库，功能更加强大，另外<code>JavaScript</code>和 <code>Perl</code>语言里面也会兼容这种模式，所以这里学习一下 <code>Perl</code>语言兼容的函数库。</p>
<p>php中 PCRE 正则共有如下函数：<br><code>preg_filter</code> — 执行一个正则表达式搜索和替换<br><code>preg_grep</code> — 返回匹配模式的数组条目<br><code>preg_last_error</code> — 返回最后一个PCRE正则执行产生的错误代码<br><code>preg_match_all</code> — 执行一个全局正则表达式匹配<br><code>preg_match</code> — 执行匹配正则表达式<br><code>preg_quote</code> — 转义正则表达式字符<br><code>preg_replace_callback_array</code> — Perform a regular expression search and replace using callbacks<br><code>preg_replace_callback</code> — 执行一个正则表达式搜索并且使用一个回调进行替换<br><code>preg_replace</code> — 执行一个正则表达式的搜索和替换<br><code>preg_split</code> — 通过一个正则表达式分隔字符串</p>
<p>常用的是<code>preg_match</code>、<code>preg_match_all</code>、<code>preg_replace</code>这三个</p>
<h2 id="preg-match"><a href="#preg-match" class="headerlink" title="preg_match"></a>preg_match</h2><p><strong>语法</strong>：<br><code>preg_match($pattern, $subject [, &amp;$matches [, $flags = 0 [, $offset = 0]]])</code> =&gt; <code>int</code></p>
<p>功能：执行正则匹配，搜索<code>subject</code>与<code>pattern</code>给定的正则表达式的一个匹配.</p>
<p><strong>参数</strong>：</p>
<ul>
<li><strong>pattern</strong> <code>string</code><br>要搜索的模式（正则表达式）</li>
<li><strong>subject</strong> <code>string</code><br>被正则匹配的字符串</li>
<li><strong>matches</strong> <code>string</code><br>如果传入了这个参数，它将被用来存放搜索结果<br><code>$match[0]</code>包含完整模式匹配到的文本，<code>$match[1]</code>包含第一个捕获分组匹配到的文本，以此类推</li>
<li><strong>flags</strong> <code>int</code><br><code>flags</code>可以设置为<code>PREG_OFFSET_CAPTURE</code>(1)<br>如果设置为1，对于每一个出现的匹配返回时会附加字符串偏移量(相对于目标字符串的)。<br>注意：这会改变填充到<code>matches</code>参数的数组，使其每个元素成为一个由 第0个元素是匹配到的字符串，第1个元素是该匹配字符串 在目标字符串<code>subject</code>中的偏移量。</li>
<li><strong>offset</strong> <code>int</code><br>通常，搜索从目标字符串的开始位置开始。可选参数<code>offset</code>用于指定从目标字符串的某个位置开始搜索(单位是字节)。<br>如果<code>offset</code>比<code>subject</code>的长度还要大则返回<code>FALSE</code>。</li>
</ul>
<p><strong>返回值</strong>：<br>返回<code>pattern</code>的匹配次数。 它的值将是0次（不匹配）或1次，因为<code>preg_match()</code>在第一次匹配后将会停止搜索。<br>如果发生错误将返回 <code>FALSE</code>。</p>
<h2 id="preg-match-all"><a href="#preg-match-all" class="headerlink" title="preg_match_all"></a>preg_match_all</h2><p><strong>语法</strong>：<br><code>preg_match_all($pattern, $subject[, &amp;$matches[, $flags = PREG_PATTERN_ORDER[, $offset = 0 ]]])</code>  =&gt; <code>int</code></p>
<p><strong>功能</strong>：<br>搜索<code>subject</code>中所有匹配<code>pattern</code>给定正则表达式的匹配结果并且将它们以<code>flag</code>指定顺序输出到<code>matches</code>中.<br>在第一个匹配找到后, 子序列继续从最后一次匹配位置搜索.</p>
<p>与 <code>preg_match</code> 用法完全一致，不过它匹配的是所有的信息。</p>
<p><strong>返回值</strong>：<br>返回完整匹配次数（可能是0），或者如果发生错误返回<code>FALSE</code>。</p>
<h2 id="preg-replace"><a href="#preg-replace" class="headerlink" title="preg_replace"></a>preg_replace</h2><p><strong>语法</strong>：<br><code>preg_replace ($pattern, $replacement, $subject[, $limit = -1[, &amp;$count]])</code> =&gt; <code>mixed</code></p>
<p><strong>功能</strong>：<br>搜索<code>subject</code>中匹配<code>pattern</code>的部分，以<code>replacement</code>进行替换。</p>
<p><strong>参数</strong>：</p>
<ul>
<li><strong>pattern</strong> <code>string</code> <code>array</code><br>要搜索的模式。可以使一个字符串或字符串数组。<br>可以使用一些PCRE修饰符。</li>
<li><strong>replacement</strong> <code>string</code> <code>array</code><br>用于替换的字符串或字符串数组。<br>如果这个参数是一个字符串，并且<code>pattern</code> 是一个数组，那么所有的模式都使用这个字符串进行替换。<br>如果<code>pattern</code>和<code>replacement</code>都是数组，每个<code>pattern</code>使用<code>replacement</code>中对应的 元素进行替换。如果<code>replacement</code>中的元素比<code>pattern</code>中的少， 多出来的<code>pattern</code>使用空字符串进行替换。</li>
<li><strong>subject</strong> <code>string</code> <code>array</code><br>要进行搜索和替换的字符串或字符串数组。<br>如果subject是一个数组，搜索和替换回在<code>subject</code> 的每一个元素上进行, 并且返回值也会是一个数组。</li>
<li><strong>limit</strong> <code>int</code><br>每个模式在每个<code>subject</code>上进行替换的最大次数。默认是 -1(无限)。</li>
<li><strong>count</strong> <code>int</code><br>如果指定，将会被填充为完成的替换次数。</li>
</ul>
<p><strong>返回值</strong>：<br>如果<code>subject</code>是一个数组，<code>preg_replace()</code>返回一个数组，其他情况下返回一个字符串。</p>
<p>如果匹配被查找到，替换后的<code>subject</code>被返回，其他情况下 返回没有改变的<code>subject</code>。如果发生错误，返回<code>NULL</code> 。</p>
<h1 id="模式修饰符（PRCE）"><a href="#模式修饰符（PRCE）" class="headerlink" title="模式修饰符（PRCE）"></a>模式修饰符（PRCE）</h1><p>PHP提供了一些模式修饰符，模式修饰符中的空格，换行符会被忽略，其他字符会导致错误。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">i 忽略大小写，匹配不考虑大小写</span><br><span class="line"></span><br><span class="line">m 多行独立匹配，如果字符串不包含[\n]等换行符就和普通正则一样。</span><br><span class="line"></span><br><span class="line">s 设置正则符号 . 可以匹配换行符[\n]，如果没有设置，正则符号.不能匹配换行符\n。</span><br><span class="line"></span><br><span class="line">x 忽略没有转义的空格</span><br><span class="line"></span><br><span class="line">e <span class="keyword">eval</span>() 对匹配后的元素执行函数。（php7移除）</span><br><span class="line"></span><br><span class="line">A 前置锚定，约束匹配仅从目标字符串开始搜索</span><br><span class="line"></span><br><span class="line">D 锁定$作为结尾，如果没有D，如果字符串包含[\n]等换行符，$依旧依旧匹配换行符。如果设置了修饰符m，修饰符D 就会被忽略。</span><br><span class="line"></span><br><span class="line">S 对非锚定的匹配进行分析</span><br><span class="line"></span><br><span class="line">U 非贪婪，如果在正则字符量词后加“?”，就可以恢复贪婪</span><br><span class="line"></span><br><span class="line">X 打开与perl 不兼容附件</span><br><span class="line"></span><br><span class="line">u 强制字符串为UTF<span class="number">-8</span>编码，一般在非UTF<span class="number">-8</span>编码的文档中才需要这个。建议UTF<span class="number">-8</span>环境中不要使用这个。</span><br></pre></td></tr></table></figure></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Dar1in9</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://dar1in9s.github.io/2020/04/27/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%AD%E6%B3%95%E5%92%8CPHP%E4%B8%AD%E7%9A%84%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0/">http://dar1in9s.github.io/2020/04/27/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%AD%E6%B3%95%E5%92%8CPHP%E4%B8%AD%E7%9A%84%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://Dar1in9s.github.io">Dar1in9's Blog</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/php/">php</a><a class="post-meta__tags" href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">正则表达式</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/04/28/%E6%AD%A3%E5%88%99%E5%AE%89%E5%85%A8%E7%9B%B8%E5%85%B3/"><i class="fa fa-chevron-left">  </i><span>正则安全相关</span></a></div><div class="next-post pull-right"><a href="/2020/04/26/php%E4%B8%AD%E5%B8%B8%E8%A7%81%E5%8F%AF%E8%83%BD%E4%BA%A7%E7%94%9Fssrf%E6%BC%8F%E6%B4%9E%E7%9A%84%E5%87%BD%E6%95%B0/"><span>php中常见可能产生ssrf漏洞的函数</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://blog-1300147235.cos.ap-chengdu.myqcloud.com/18085.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2020 By Dar1in9</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script src="/js/search/algolia.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script src="/js/katex.js"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>